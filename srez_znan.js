/*Задание 1: Используем метод split, filter и свойство length:
Создайте функцию, которая принимает строку и один символ и возвращает целое число, соответствующее количеству вхождений второго аргумента в первом.
Если вхождений не найдено, должно быть возвращено число 0.*/

function strCount(str, letter){  
  return str.split('').filter(c => c == letter).length;
}
/*Задание 2: Использовать map и reduce: Завершите функцию квадратной суммы, чтобы она возводила в квадрат каждое переданное ей число, а затем суммировала результаты.
Например, for [1, 2, 2]он должен возвращаться 9*/ 

function squareSum(numbers){
return numbers.map(num => num*num).reduce((acc, curr) => acc + curr, 0);
 }
 /*Задание 3: Math.sqrt и условное ветвление:Ваша задача состоит в том, чтобы найти ближайшее квадратное число nearest_sq(n)или nearestSq(n)положительное целое число n.
Например, если n = 111, то nearest\_sq(n)( nearestSq(n)) равно 121, так как 111 ближе к 121, квадрату 11, чем 100, квадрату 10.
Если это nуже идеальный квадрат (например n = 144, n = 81, и т. д.), вам нужно просто вернуть n.*/ 

function nearestSq(n){

    let root = Math.sqrt(n);
    let lower = Math.floor(root) ** 2; //округление до меньшего
    let upper = Math.ceil(root) ** 2; //округление до большего
    return (n - lower < upper - n) ? lower : upper; //условное ветвление-тернарный оператор 
  } 
  console.log(nearestSq(111)); // 121
  console.log(nearestSq(144)); // 144

  /*Задание 4: Split, reverse, join: Завершите решение так, чтобы оно перевернуло переданную в него строку.
'world'  =>  'dlrow'
'word'   =>  'drow'*/

    function solution(str){
    return str.split('').reverse().join('');
   }

/*Задание 5: Split, length, map: Что, если нам нужно, чтобы длина слов, разделенных пробелом, была добавлена ​​в конце того же слова и возвращена в виде массива?
Пример (ввод --> вывод)
"apple ban" --> ["apple 5", "ban 3"]
"you will win" -->["you 3", "will 4", "win 3"]
Ваша задача — написать функцию, которая принимает строку и возвращает массив/список с длиной каждого слова, добавленного к каждому элементу.
Примечание. Строка будет содержать как минимум один элемент; слова всегда будут разделены пробелом*/

function addLength(str) {
    const words = str.split(' '); //разделяем строку на слова
    return words.map(word => `${word} ${word.length}`); //добавляем длину каждого слова в конец и возвращаем новый массив
  }
  console.log(addLength("apple ban")); // ["apple 5", "ban 3"]
  console.log(addLength("you will win")); //["you 3", "will 4", "win 3"] 

/*Задание 6:Арифметические операторы, условное ветвление:Есть предложение «3 по цене 2» (или «2+1» , если хотите) на манго. Для данного количества и цены (за манго) рассчитайте общую стоимость манго.
Примеры
mango(2, 3) ==> 6    # 2 mangoes for $3 per unit = $6; no mango for free
mango(3, 3) ==> 6    # 2 mangoes for $3 per unit = $6; +1 mango for free
mango(5, 3) ==> 12   # 4 mangoes for $3 per unit = $12; +1 mango for free
mango(9, 5) ==> 30   # 6 mangoes for $5 per unit = $30; +3 mangoes for free */ 

function mango(quantity, price){ //количество, цена
    let x = 0
    if (quantity >= 3){ //количество манго
      let freeMangoes = Math.floor(quantity / 3); // количество бесплатных манго за каждые 3 купленных, округляем результат деления
      x = (quantity-freeMangoes) * price; //общая сумма купленных манго 
    } else {
      x = quantity * price; //если купили меньше 3 манго, общая сумма
    }
      return x;
    }
    console.log(mango(2, 3)); //6
    console.log(mango(3, 3)); //6
    console.log(mango(5, 3)); //12
    console.log(mango(9, 5)); //30

/*Задание 7 : Арифметические операторы, Math.floor(): Натан любит кататься на велосипеде.
Поскольку Натан знает, как важно избегать обезвоживания, он выпивает 0,5 литра воды за час езды на велосипеде.
Вам дается время в часах, и вам нужно вернуть количество литров, которые выпьет Натан, округленное до наименьшего значения.
Например:
time = 3 ----> litres = 1
time = 6.7---> litres = 3
time = 11.8--> litres = 5 */
function litres(time) {
    return Math.floor(time*0.5); //умножаем время на кол-во литров в час и округляем до меньшего
  }
   console.log(litres(3));//1
   console.log(litres(6.7));//3
   console.log(litres(11.8));//5

/*Задание 8 : map(), условный оператор: Учитывая набор чисел, верните добавку, обратную каждому из них. Каждое положительное становится отрицательным, а отрицательное становится положительным.
invert([1,2,3,4,5]) == [-1,-2,-3,-4,-5]
invert([1,-2,3,-4,5]) == [-1,2,-3,4,-5]
invert([]) == []
Можно предположить, что все значения являются целыми числами. Не изменяйте входной массив/список*/

function invert(array) {
    return array.map(n => -n)  ; //каждый положительный элемент * -1 и становится отрицательным
 }
 
/*Задание 9 : Цикл, Math.pow(): Завершите функцию, которая принимает неотрицательное целое число n в качестве входных данных и возвращает список всех степеней 2с показателем степени от 0до n( включительно ).
Примеры
n = 0  ==> [1]        # [2^0]
n = 1  ==> [1, 2]     # [2^0, 2^1]
n = 2  ==> [1, 2, 4]  # [2^0, 2^1, 2^2] */

function powersOfTwo(n){
   let result = [];
  for (let i = 0; i <= n; i++) { //цикл для повторения операций 
    result.push(Math.pow(2,i)); //добавляем возведение в степень 
  }
  return result; //возвращаем готовый массив
}

/* Задание 10 : length, условный оператор, reduce: Учитывая непустой массив целых чисел, вернуть результат умножения значений вместе по порядку. Пример:
[1, 2, 3, 4] => 1 * 2 * 3 * 4 = 24*/

// Решение с помощью цикла и условного оператора
function grow(x){
    let result = 1;
    for (let i = 0; i < x.length; i++) { //перебираем каждый элемент
      if (x[i] !== 0) {
        result *= x[i]; // умножаем каждый элемент
      }
    }
    return result;
  }
  // Решение с помощью метода reduce
  function grow(x){
    return x.reduce((accumulator, currentValue) => accumulator * currentValue, 1); // получаем 1 итог всех умножений
  
  }

